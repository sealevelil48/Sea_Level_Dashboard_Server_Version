<!DOCTYPE html>
<html>
<head>
    <title>GOVMAP - Sea Level Stations</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://www.govmap.gov.il/govmap/api/govmap.api.js"></script>
    <script>
        // Edge compatibility polyfill
        if (!window.fetch) {
            window.fetch = function(url, options) {
                return new Promise(function(resolve, reject) {
                    var xhr = new XMLHttpRequest();
                    xhr.open(options && options.method || 'GET', url);
                    xhr.onload = function() {
                        resolve({
                            ok: xhr.status >= 200 && xhr.status < 300,
                            json: function() { return Promise.resolve(JSON.parse(xhr.responseText)); }
                        });
                    };
                    xhr.onerror = reject;
                    xhr.send(options && options.body);
                });
            };
        }
    </script>
    <style>
        body { margin: 0; padding: 0; font-family: Arial, sans-serif; }
        #map { width: 100%; height: 500px; }
        .loading { 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 500px; 
            background: #f0f0f0;
            color: #333;
        }
        .error {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 500px;
            background: #ffe6e6;
            color: #d00;
            text-align: center;
        }
        
        /* CRITICAL: Mobile PORTRAIT ONLY positioning - Fixed to prevent landscape regression */
        @media screen and (max-width: 768px) and (orientation: portrait) {
            /* Target all possible popup elements - but ONLY in portrait */
            .govmap-bubble,
            div[style*="position: absolute"],
            div[style*="position: fixed"],
            div[class*="bubble"],
            div[class*="popup"],
            div[class*="tooltip"] {
                position: fixed !important;
                right: 5px !important;
                top: 50% !important;
                transform: translateY(-50%) !important;
                left: auto !important;
                bottom: auto !important;
                max-width: 250px !important;
                max-height: 80vh !important; /* Prevent overflow */
                z-index: 99999 !important;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3) !important;
                border-radius: 8px !important;
                overflow-y: auto !important; /* Allow scrolling if content too long */
            }
            
            /* Override any GovMap specific positioning - PORTRAIT ONLY */
            #map div[style*="position"] {
                position: fixed !important;
                right: 5px !important;
                top: 50% !important;
                transform: translateY(-50%) !important;
                left: auto !important;
                bottom: auto !important;
                z-index: 99999 !important;
            }
        }
        
        /* LANDSCAPE MODE - Reset to default behavior */
        @media screen and (max-width: 992px) and (orientation: landscape) {
            /* Allow GovMap default positioning in landscape */
            .govmap-bubble,
            div[class*="bubble"],
            div[class*="popup"] {
                position: absolute !important;
                max-width: 300px !important;
                max-height: 60vh !important;
                /* Let GovMap handle positioning naturally */
            }
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">
        <div>Loading GovMap...</div>
    </div>
    <div id="map" style="display: none;"></div>
    <div id="error" class="error" style="display: none;">
        <div>
            <h3>GovMap Unavailable</h3>
            <p>Unable to load GovMap API or station data</p>
        </div>
    </div>
    <script>
        function showError(message) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('map').style.display = 'none';
            document.getElementById('error').style.display = 'flex';
            console.error('GovMap Error:', message);
        }
        
        function showMap() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').style.display = 'none';
            document.getElementById('map').style.display = 'block';
        }
        
        // CRITICAL: Helper function to detect TRUE portrait orientation
        function isMobilePortrait() {
            return window.innerWidth <= 768 && window.innerHeight > window.innerWidth;
        }
        
        // CRITICAL: Helper function to detect landscape orientation
        function isMobileLandscape() {
            return window.innerWidth <= 992 && window.innerWidth >= window.innerHeight;
        }
        
        // IMS Code Translation Functions
        const seaStateCodes = {
            10: "Calm", 20: "Rippled", 30: "Smooth", 40: "Smooth to slight", 50: "Slight",
            55: "Slight to moderate", 60: "Moderate", 70: "Moderate to rough", 80: "Rough",
            90: "Rough to very rough", 110: "Very rough", 120: "Very rough to high",
            130: "High", 140: "High to very high", 150: "Very high", 160: "Phenomenal"
        };
        
        const windDirections = {
            "045": "NE", "090": "E", "135": "SE", "180": "S", "225": "SW", "270": "W", "315": "NW", "360": "N"
        };
        
        function translateWaveHeight(waveString) {
            if (!waveString || typeof waveString !== 'string') return waveString;
            
            const parts = waveString.split(' / ');
            if (parts.length !== 2) {
                const code = parseInt(waveString.trim());
                return seaStateCodes[code] || waveString;
            }
            
            const code = parseInt(parts[0].trim());
            const actualHeight = parts[1].trim();
            const translatedCode = seaStateCodes[code] || parts[0].trim();
            
            return translatedCode + ' (' + actualHeight + ' cm)';
        }
        
        function translateWindInfo(windString) {
            if (!windString || typeof windString !== 'string') return windString;
            
            const parts = windString.split('/');
            if (parts.length !== 2) return windString;
            
            const directions = parts[0];
            const speeds = parts[1];
            
            let translatedDirections = directions;
            if (directions.includes('-')) {
                const dirParts = directions.split('-');
                const dir1 = dirParts[0].padStart(3, '0');
                const dir2 = dirParts[1].padStart(3, '0');
                const trans1 = windDirections[dir1] || dirParts[0];
                const trans2 = windDirections[dir2] || dirParts[1];
                translatedDirections = trans1 + '-' + trans2;
            } else {
                const dir = directions.padStart(3, '0');
                translatedDirections = windDirections[dir] || directions;
            }
            
            return translatedDirections + ' (' + speeds.trim() + ' km/h)';
        }
        
        let mapInstance;
        let stationsData = [];
        let forecastData = [];
        
        // Weather risk color functions
        function getWaveRiskColor(waveString) {
            if (!waveString) return '#6c757d';
            const code = parseInt(waveString.split(' / ')[0] || waveString);
            if (code >= 80) return '#dc3545';  // red
            if (code >= 60) return '#fd7e14';  // orange
            if (code >= 40) return '#ffc107';  // yellow
            return '#6c757d';                  // grey
        }
        
        function getWindRiskColor(windString) {
            if (!windString) return '#6c757d';
            const speedPart = windString.split('/')[1];
            if (!speedPart) return '#6c757d';
            const maxSpeed = Math.max(...speedPart.split('-').map(s => parseInt(s.trim())));
            if (maxSpeed >= 40) return '#dc3545';  // red
            if (maxSpeed >= 25) return '#fd7e14';  // orange
            if (maxSpeed >= 15) return '#ffc107';  // yellow
            return '#6c757d';                      // grey
        }
        
        // Initialize translation functions globally
        window.translateWaveHeight = translateWaveHeight;
        window.translateWindInfo = translateWindInfo;
        window.getWaveRiskColor = getWaveRiskColor;
        window.getWindRiskColor = getWindRiskColor;
        
        window.onload = function() {
            // Add delay for Edge browser
            setTimeout(function() {
                try {
                    if (typeof govmap === 'undefined') {
                        throw new Error('GovMap API not loaded');
                    }
                
                govmap.token = "11aa3021-4ae0-4771-8ae0-df75e73fe73e";
                
                const convertToITM = (lon, lat) => {
                    const x = 219529 + (lon - 35.2045) * 111320 * Math.cos(lat * Math.PI / 180);
                    const y = 626907 + (lat - 31.7344) * 111320;
                    return { x: Math.round(x), y: Math.round(y) };
                };
                
                const displayAllMarkers = () => {
                    if (stationsData.length === 0) return;
                    
                    const wkts = [];
                    const names = [];
                    const symbols = [];
                    const tooltips = [];
                    const bubbleHTMLParameters = [];
                    
                    // Station to forecast mapping
                    const stationForecastMap = {
                        'Acre': 'Northern Coast',
                        'Yafo': 'Central Coast', 
                        'Ashkelon': 'Southern Coast',
                        'Eilat': 'Gulf of Eilat'
                    };
                    
                    // Add stations with combined data
                    stationsData.forEach((station) => {
                        wkts.push(`POINT(${station.x} ${station.y})`);
                        names.push(`station_${station.Station}`);
                        symbols.push({
                            url: 'data:image/svg+xml;base64,' + btoa('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#2196F3"/></svg>'),
                            width: 32,
                            height: 32
                        });
                        
                        // Find matching forecast data
                        const forecastLocation = stationForecastMap[station.Station];
                        const matchingForecast = forecastData.find(f => f.name_eng === forecastLocation);
                        
                        if (matchingForecast) {
                            const currentForecast = matchingForecast.forecasts[0];
                            tooltips.push(`${station.Station} - Combined Data`);
                            
                            const waveHeight = translateWaveHeight(currentForecast?.elements?.wave_height || 'N/A');
                            const windInfo = translateWindInfo(currentForecast?.elements?.wind || 'N/A');
                            
                            const forecastHTML = `<hr style="margin: 15px 0; border: none; border-top: 1px solid #ddd;">
                                <h4 style="margin: 0 0 10px 0; color: #ff8c00;">${forecastLocation}</h4>
                                <div><strong>Wave Height:</strong> ${waveHeight}</div>
                                <div><strong>Sea Temperature:</strong> ${currentForecast?.elements?.sea_temperature || 'N/A'}°C</div>
                                <div><strong>Wind:</strong> ${windInfo}</div>
                                <div style="font-size: 12px; color: #7f8c8d; margin-top: 10px;">
                                    <strong>Forecast Period:</strong><br>${currentForecast?.from || 'N/A'} - ${currentForecast?.to || 'N/A'}
                                </div>
                                <div style="font-size: 11px; color: #888; margin-top: 5px;">
                                    <a href="https://ims.gov.il/he/coasts" target="_parent" style="color: #666; text-decoration: none;">IMS Forecast ©</a>
                                </div>`;
                            
                            bubbleHTMLParameters.push([
                                station.Station,
                                `<strong>Sea Level:</strong> ${station.latest_value} m`,
                                `<strong>Temperature:</strong> ${station.temperature || 'N/A'}°C`,
                                `<strong>Last Update:</strong> ${station.last_update}<div style="font-size: 11px; color: #888; margin-top: 10px;"><a href="https://www.gov.il/he/departments/survey_of_israel/govil-landing-page" target="_parent" style="color: #666; text-decoration: none;">© 2025 Survey of Israel. All rights reserved.</a></div>${forecastHTML}`
                            ]);
                        } else {
                            tooltips.push(`${station.Station} - ${station.latest_value}m`);
                            bubbleHTMLParameters.push([
                                station.Station,
                                `<strong>Sea Level:</strong> ${station.latest_value} m`,
                                `<strong>Temperature:</strong> ${station.temperature || 'N/A'}°C`,
                                `<strong>Last Update:</strong> ${station.last_update}<div style="font-size: 11px; color: #888; margin-top: 10px;"><a href="https://www.gov.il/he/departments/survey_of_israel/govil-landing-page" target="_parent" style="color: #666; text-decoration: none;">© 2025 Survey of Israel. All rights reserved.</a></div>`
                            ]);
                        }
                    });
                    
                    // Add Sea of Galilee forecast marker (standalone)
                    const seaOfGalilee = forecastData.find(f => f.name_eng === 'Sea of Galilee');
                    if (seaOfGalilee) {
                        const coords = seaOfGalilee.coordinates;
                        const itm = convertToITM(coords.lng, coords.lat);
                        wkts.push(`POINT(${itm.x} ${itm.y})`);
                        names.push(`forecast_sea_of_galilee`);
                        symbols.push({
                            url: 'data:image/svg+xml;base64,' + btoa('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#2196F3"/></svg>'),
                            width: 32,
                            height: 32
                        });
                        
                        const currentForecast = seaOfGalilee.forecasts[0];
                        const waveHeight = translateWaveHeight(currentForecast?.elements?.wave_height || 'N/A');
                        const windInfo = translateWindInfo(currentForecast?.elements?.wind || 'N/A');
                        
                        tooltips.push(`${seaOfGalilee.name_eng} - Wave Forecast`);
                        bubbleHTMLParameters.push([
                            seaOfGalilee.name_eng,
                            `<strong>Wave Height:</strong> ${waveHeight}`,
                            `<strong>Sea Temperature:</strong> ${currentForecast?.elements?.sea_temperature || 'N/A'}°C`,
                            `<strong>Wind:</strong> ${windInfo}<div style="font-size: 12px; color: #7f8c8d; margin-top: 10px;"><strong>Forecast Period:</strong><br>${currentForecast?.from || 'N/A'} - ${currentForecast?.to || 'N/A'}</div><div style="font-size: 11px; color: #888; margin-top: 10px;"><a href="https://ims.gov.il/he/coasts" target="_parent" style="color: #666; text-decoration: none;">IMS Forecast ©</a></div>`
                        ]);
                    }
                    
                    govmap.displayGeometries({
                        wkts: wkts,
                        names: names,
                        geometryType: govmap.geometryType.POINT,
                        symbols: symbols,
                        clearExisting: true,
                        data: {
                            tooltips: tooltips,
                            bubbleHTML: `
                                <div class="govmap-bubble" style="font-family: Arial, sans-serif; padding: 15px; min-width: 250px; direction: ltr; text-align: left;">
                                    <h4 style="margin: 0 0 15px 0; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 5px; direction: ltr; text-align: left;">{0}</h4>
                                    <div style="margin: 8px 0; direction: ltr; text-align: left;">{1}</div>
                                    <div style="margin: 8px 0; direction: ltr; text-align: left;">{2}</div>
                                    <div style="margin: 8px 0; direction: ltr; text-align: left;">{3}</div>
                                </div>
                            `,
                            bubbleHTMLParameters: bubbleHTMLParameters
                        }
                    });
                    
                    // CRITICAL FIX: Apply mobile positioning ONLY in portrait orientation
                    setTimeout(() => {
                        // PORTRAIT MODE ONLY
                        if (isMobilePortrait()) {
                            const forcePortraitPosition = (element) => {
                                if (!element) return;
                                element.style.setProperty('position', 'fixed', 'important');
                                element.style.setProperty('right', '5px', 'important');
                                element.style.setProperty('top', '50%', 'important');
                                element.style.setProperty('transform', 'translateY(-50%)', 'important');
                                element.style.setProperty('left', 'auto', 'important');
                                element.style.setProperty('bottom', 'auto', 'important');
                                element.style.setProperty('width', 'auto', 'important');
                                element.style.setProperty('max-width', '250px', 'important');
                                element.style.setProperty('max-height', '80vh', 'important');
                                element.style.setProperty('z-index', '99999', 'important');
                                element.style.setProperty('box-shadow', '0 4px 12px rgba(0,0,0,0.3)', 'important');
                                element.style.setProperty('border-radius', '8px', 'important');
                                element.style.setProperty('overflow-y', 'auto', 'important');
                            };
                            
                            const applyPortraitPositioning = () => {
                                // Double-check we're still in portrait before applying
                                if (!isMobilePortrait()) {
                                    console.log('Orientation changed, skipping portrait positioning');
                                    return;
                                }
                                
                                // Target all possible popup selectors
                                const selectors = [
                                    '.govmap-bubble',
                                    'div[style*="position: absolute"]',
                                    'div[style*="position: fixed"]',
                                    'div[class*="bubble"]',
                                    'div[class*="popup"]',
                                    'div[class*="tooltip"]',
                                    '#map > div > div',
                                    '#map div[style]'
                                ];
                                
                                selectors.forEach(selector => {
                                    const elements = document.querySelectorAll(selector);
                                    elements.forEach(element => {
                                        // Check if element contains popup-like content
                                        if (element.innerHTML && (
                                            element.innerHTML.includes('Sea Level') || 
                                            element.innerHTML.includes('Wave Height') || 
                                            element.innerHTML.includes('Temperature')
                                        )) {
                                            forcePortraitPosition(element);
                                            
                                            // Also position parent containers (up to 3 levels)
                                            let parent = element.parentElement;
                                            let depth = 0;
                                            while (parent && parent !== document.body && depth < 3) {
                                                if (parent.style.position) {
                                                    forcePortraitPosition(parent);
                                                }
                                                parent = parent.parentElement;
                                                depth++;
                                            }
                                        }
                                    });
                                });
                            };
                            
                            // Apply immediately
                            applyPortraitPositioning();
                            
                            // Re-apply on any DOM changes (but check orientation first)
                            const observer = new MutationObserver(() => {
                                if (isMobilePortrait()) {
                                    setTimeout(applyPortraitPositioning, 50);
                                }
                            });
                            observer.observe(document.body, { 
                                childList: true, 
                                subtree: true, 
                                attributes: true, 
                                attributeFilter: ['style', 'class'] 
                            });
                            
                            // Also apply on click events (when popups are opened)
                            document.addEventListener('click', () => {
                                if (isMobilePortrait()) {
                                    setTimeout(applyPortraitPositioning, 100);
                                }
                            });
                        }
                        
                        // LANDSCAPE MODE - Remove forced positioning
                        if (isMobileLandscape()) {
                            const resetLandscapePosition = () => {
                                const selectors = [
                                    '.govmap-bubble',
                                    'div[class*="bubble"]',
                                    'div[class*="popup"]'
                                ];
                                
                                selectors.forEach(selector => {
                                    const elements = document.querySelectorAll(selector);
                                    elements.forEach(element => {
                                        // Reset to GovMap's default positioning
                                        element.style.removeProperty('position');
                                        element.style.removeProperty('right');
                                        element.style.removeProperty('top');
                                        element.style.removeProperty('transform');
                                        element.style.removeProperty('left');
                                        element.style.removeProperty('bottom');
                                        element.style.removeProperty('width');
                                        
                                        // Set reasonable landscape constraints
                                        element.style.setProperty('max-width', '300px', 'important');
                                        element.style.setProperty('max-height', '60vh', 'important');
                                    });
                                });
                            };
                            
                            resetLandscapePosition();
                        }
                        
                        // CRITICAL: Listen for orientation changes
                        window.addEventListener('orientationchange', () => {
                            setTimeout(() => {
                                // Re-evaluate and apply appropriate positioning
                                if (isMobilePortrait()) {
                                    console.log('Switched to portrait');
                                    // Trigger portrait positioning
                                    const event = new Event('click');
                                    document.dispatchEvent(event);
                                } else if (isMobileLandscape()) {
                                    console.log('Switched to landscape - resetting position');
                                    // Reset any forced positioning
                                    const bubbles = document.querySelectorAll('.govmap-bubble, div[class*="bubble"], div[class*="popup"]');
                                    bubbles.forEach(bubble => {
                                        bubble.style.removeProperty('position');
                                        bubble.style.removeProperty('right');
                                        bubble.style.removeProperty('top');
                                        bubble.style.removeProperty('transform');
                                        bubble.style.setProperty('max-width', '300px', 'important');
                                        bubble.style.setProperty('max-height', '60vh', 'important');
                                    });
                                }
                            }, 300); // Delay to ensure orientation change is complete
                        });
                        
                        // Also listen for resize events (for browsers that don't fire orientationchange)
                        let resizeTimer;
                        window.addEventListener('resize', () => {
                            clearTimeout(resizeTimer);
                            resizeTimer = setTimeout(() => {
                                const event = new Event('orientationchange');
                                window.dispatchEvent(event);
                            }, 250);
                        });
                    }, 100);
                };
                
                const fetchAndDisplayStations = (endDate) => {
                    const apiUrl = window.location.protocol + '//' + window.location.host;
                    fetch(`${apiUrl}/stations/map?end_date=${endDate}`)
                        .then(response => response.json())
                        .then(data => {
                            if (!Array.isArray(data) || data.length === 0) {
                                throw new Error('No station data');
                            }
                            stationsData = data;
                            displayAllMarkers();
                            showMap();
                        })
                        .catch(error => showError('Failed: ' + error.message));
                };
                
                const fetchWaveForecast = () => {
                    const apiUrl = window.location.protocol + '//' + window.location.host;
                    fetch(`${apiUrl}/sea-forecast`)
                        .then(response => response.json())
                        .then(data => {
                            if (data && data.locations) {
                                forecastData = data.locations;
                                displayAllMarkers();
                            }
                        })
                        .catch(error => console.warn('Wave forecast fetch failed:', error));
                };
                
                window.addEventListener('message', (event) => {
                    if (event.data && event.data.type === 'UPDATE_DATE') {
                        fetchAndDisplayStations(event.data.payload);
                    }
                });
                
                const today = new Date().toISOString().split('T')[0];
                fetchAndDisplayStations(today);
                fetchWaveForecast();
                
                mapInstance = govmap.createMap("map", {
                    token: govmap.token,
                    layers: [],
                    center: { x: 176505, y: 662250 },
                    zoom: 0,
                    basemap: '2'
                });
                
            } catch (error) {
                showError('Init failed: ' + error.message);
            }
            }, 1000); // 1 second delay for Edge
        };
        
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'UPDATE_STATIONS') {
                stationsData = event.data.stations;
            }
        });
    </script>
</body>
</html>